<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 
	int maxBases = 7;
	int maxParameters = 15;
#>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using NMF.Models;

namespace NMF.Expressions
{
<# for (int bases = 1; bases <= maxBases; bases++) {
   for (int parameters = 1; parameters <= maxParameters; parameters++) { #>
    internal abstract class ObservableModelFuncProxyCall<#= bases #>Bases<#= parameters #>Parameters<<# for (int b = 1; b <= bases; b++) { #>TBase<#= b #>, <# } #><# for (int p = 1; p <= parameters; p++) { #> TPar<#= p #>, <# } #>TResult> : NotifyExpression<TResult>
    {
        public abstract INotifyExpression<TResult> Func { get; }

<# for (int p = 1; p <= parameters; p++) { #>
        public ModelFuncExtractionParameter<<# for (int b = 1; b <= bases; b++) { #>TBase<#= b #>, <# } #>TPar<#= p #>> Parameter<#= p #> { get; private set; }
<# } #>

        public override bool IsParameterFree
        {
            get
            {
                return false;
            }
        }

        public ObservableModelFuncProxyCall<#= bases #>Bases<#= parameters #>Parameters(INotifyExpression<TBase1> argument1<# for(int b = 2; b <= bases; b++) { #>, INotifyExpression<TBase<#= b #>> argument<#= b #><# } #><# for(int p = 1; p <= parameters; p++) { #>, Func<<# for (int b = 1; b <= bases; b++) { #>TBase<#= b #>, <# } #>TPar<#= p #>> selector<#= p #><# } #>)
        {
<# for (int p = 1; p <= parameters; p++) { #>
            Parameter<#= p #> = new ModelFuncExtractionParameter<<# for(int b = 1; b <= bases; b++) { #>TBase<#= b #>, <# } #>TPar<#= p #>>(<# for(int b = 1; b <= bases; b++) { #>argument<#= b #>, <# } #>selector<#= p #>);
<# } #>
        }

        protected override void AttachCore()
        {
<# for(int b = 1; b <= bases; b++) { #>
            Parameter1.Base<#= b #>.Attach();
            Parameter1.Base<#= b #>.ValueChanged += RefreshFunc;
<# } #>
        }

        private void RefreshFunc(object sender, ValueChangedEventArgs e)
        {
            Func.Refresh();
            Refresh();
        }

        protected override void DetachCore()
        {
<# for(int b = 1; b <= bases; b++) { #>
            Parameter1.Base<#= b #>.Detach();
            Parameter1.Base<#= b #>.ValueChanged -= RefreshFunc;
<# } #>
        }

        protected override TResult GetValue()
        {
            return Func.Value;
        }
    }
<# }} #>
}
